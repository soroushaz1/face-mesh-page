<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>FaceMesh + Camera Select + Textured OBJ Export</title>

  <!-- MediaPipe & utils -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <!-- Delaunator for triangulation -->
  <script src="https://cdn.jsdelivr.net/npm/delaunator@5.0.0/delaunator.min.js"></script>

  <style>
    /* General page styling */
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      background: linear-gradient(45deg, #6a11cb 0%, #2575fc 100%);
      overflow: hidden;
    }

    /* Container with glassmorphism */
    .container {
      position: relative;
      width: 80%;
      height: 80%;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
      padding: 20px;
      transition: transform 0.3s ease;
    }

    .container:hover {
      transform: scale(1.05);
    }

    /* Video & canvas */
    video, canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 16px;
      transition: opacity 0.5s ease;
    }

    /* Controls bar with hover effects */
    #controls {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 2;
      display: flex;
      gap: 12px;
      background: rgba(0, 0, 0, 0.6);
      padding: 12px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      opacity: 0.9;
      transition: opacity 0.3s ease;
    }

    #controls:hover {
      opacity: 1;
    }

    #controls select, #controls button {
      font-size: 16px;
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.3s ease, transform 0.3s ease;
    }

    #controls select {
      background: #333;
      color: #fff;
    }

    #controls button {
      background: #007BFF;
      color: white;
      font-weight: bold;
    }

    #controls button:hover {
      background: #0056b3;
      transform: translateY(-2px);
    }

    #controls select:focus, #controls button:focus {
      outline: none;
      box-shadow: 0 0 5px rgba(0, 123, 255, 0.8);
    }

    /* Buy Me a Coffee Button with smooth hover animation */
    #buyMeACoffeeBtn {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 20px;
      background-color: #ff813f;
      color: white;
      font-size: 18px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      border: none;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.3s ease;
    }

    #buyMeACoffeeBtn:hover {
      background-color: #e75a29;
      transform: scale(1.1);
    }

    #buyMeACoffeeBtn:focus {
      outline: none;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .container {
        width: 100%;
        height: 100%;
      }

      #controls {
        flex-direction: column;
        gap: 8px;
        top: 10px;
        left: 10px;
      }

      #controls select, #controls button {
        font-size: 14px;
        padding: 6px 12px;
      }

      #buyMeACoffeeBtn {
        bottom: 10px;
      }
    }

    /* Particle background effect */
    .particles {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
    }

    .particle {
      position: absolute;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.6);
      opacity: 0;
      animation: particle-animation 5s linear infinite;
    }

    @keyframes particle-animation {
      0% { transform: translate(0, 0); opacity: 1; }
      100% { transform: translate(200px, -300px); opacity: 0; }
    }
  </style>
</head>
<body>

  <!-- Particle effect (background animation) -->
  <div class="particles"></div>

  <!-- Container with UI elements -->
  <div class="container">
    <!-- Controls: camera selector, start, toggle mesh, download -->
    <div id="controls">
      <select id="cameraSelect"></select>
      <button id="startCamBtn">Start Camera</button>
      <button id="toggleMeshBtn">Show Mesh</button>
      <button id="downloadBtn">Download OBJ+Texture</button>
    </div>

    <!-- Hidden video feed and overlay canvas -->
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>

    <!-- Buy Me a Coffee Button -->
    <button id="buyMeACoffeeBtn" onclick="window.open('https://buymeacoffee.com/soroushzenw', '_blank')">Support Me on BuyMeACoffee</button>
  </div>

  <script>
    // DOM refs
    const videoEl      = document.getElementById('video');
    const canvasEl     = document.getElementById('overlay');
    const ctx          = canvasEl.getContext('2d');
    const selectCam    = document.getElementById('cameraSelect');
    const startCamBtn  = document.getElementById('startCamBtn');
    const toggleMeshBtn= document.getElementById('toggleMeshBtn');
    const downloadBtn  = document.getElementById('downloadBtn');

    // State
    let stream         = null;
    let stopLoop       = false;
    let showMesh       = false;
    let lastLM         = null;
    let lastTriangles  = null;

    // Particle Effect Generation
    function createParticle() {
      const particle = document.createElement('div');
      particle.classList.add('particle');
      document.querySelector('.particles').appendChild(particle);

      const size = Math.random() * 5 + 2;
      const left = Math.random() * 100 + '%';
      const animationDuration = Math.random() * 3 + 2;

      particle.style.width = `${size}px`;
      particle.style.height = `${size}px`;
      particle.style.left = left;
      particle.style.animationDuration = `${animationDuration}s`;

      setTimeout(() => {
        particle.remove();
      }, animationDuration * 1000);
    }

    // Create particles every 100ms
    setInterval(createParticle, 100);

    // Initialize MediaPipe FaceMesh
    const faceMesh = new FaceMesh({
      locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`
    });
    faceMesh.setOptions({
      maxNumFaces: 1,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });
    faceMesh.onResults(onResults);

    // List available video input devices
    async function listCameras() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === 'videoinput');
      selectCam.innerHTML = '';
      cams.forEach((cam, i) => {
        const opt = document.createElement('option');
        opt.value = cam.deviceId;
        opt.text  = cam.label || `Camera ${i+1}`;
        selectCam.appendChild(opt);
      });
    }
    listCameras();

    // Start camera with chosen deviceId
    startCamBtn.addEventListener('click', async () => {
      // Stop existing tracks & loop
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stopLoop = true;
      }
      const deviceId = selectCam.value;
      stream = await navigator.mediaDevices.getUserMedia({
        video: { deviceId: { exact: deviceId }, width: 640, height: 480 }
      });
      videoEl.srcObject = stream;
      await videoEl.play();

      // Kick off our own frame loop feeding FaceMesh
      stopLoop = false;
      (async function frameLoop() {
        await faceMesh.send({ image: videoEl });
        if (!stopLoop) requestAnimationFrame(frameLoop);
      })();
    });

    // Handle results & draw
    function onResults(results) {
      lastLM = results.multiFaceLandmarks?.[0] || null;
      canvasEl.width  = videoEl.videoWidth;
      canvasEl.height = videoEl.videoHeight;

      ctx.save();
      ctx.clearRect(0,0,canvasEl.width,canvasEl.height);
      ctx.drawImage(results.image, 0,0, canvasEl.width,canvasEl.height);

      if (lastLM) {
        // 2D points for triangulation
        const pts = lastLM.map(lm => [
          lm.x * canvasEl.width,
          lm.y * canvasEl.height
        ]);
        lastTriangles = Delaunator.from(pts).triangles;

        // Fill triangles if toggled
        if (showMesh) {
          ctx.fillStyle = 'rgba(0,255,0,0.3)';
          for (let i=0; i<lastTriangles.length; i+=3) {
            const a = lastTriangles[i],
                  b = lastTriangles[i+1],
                  c = lastTriangles[i+2];
            ctx.beginPath();
            ctx.moveTo(pts[a][0], pts[a][1]);
            ctx.lineTo(pts[b][0], pts[b][1]);
            ctx.lineTo(pts[c][0], pts[c][1]);
            ctx.closePath();
            ctx.fill();
          }
        }

        // Always draw landmark dots
        ctx.fillStyle = 'lime';
        for (const lm of lastLM) {
          const x = lm.x * canvasEl.width,
                y = lm.y * canvasEl.height;
          ctx.beginPath();
          ctx.arc(x,y,2,0,2*Math.PI);
          ctx.fill();
        }
      }
      ctx.restore();
    }

    // Toggle mesh on/off
    toggleMeshBtn.addEventListener('click', () => {
      showMesh = !showMesh;
      toggleMeshBtn.textContent = showMesh ? 'Hide Mesh' : 'Show Mesh';
    });

    // Download OBJ + MTL + texture
    downloadBtn.addEventListener('click', async () => {
      if (!lastLM || !lastTriangles) {
        return alert('No face mesh detected yet!');
      }
      // Capture texture
      const texCanvas = document.createElement('canvas');
      texCanvas.width  = videoEl.videoWidth;
      texCanvas.height = videoEl.videoHeight;
      const texCtx = texCanvas.getContext('2d');
      texCtx.drawImage(videoEl, 0,0, texCanvas.width,texCanvas.height);
      const texBlob = await new Promise(res => texCanvas.toBlob(res,'image/png'));

      // Build OBJ (v, vt, f)
      const verts = lastLM.map(lm =>
        `v ${lm.x.toFixed(6)} ${lm.y.toFixed(6)} ${lm.z.toFixed(6)}`
      );
      const uvs = lastLM.map(lm => {
        const u = lm.x.toFixed(6);
        const v = (1 - lm.y).toFixed(6);
        return `vt ${u} ${v}`;
      });
      const faces = [];
      for (let i=0; i<lastTriangles.length; i+=3) {
        const a = lastTriangles[i]   +1,
              b = lastTriangles[i+1] +1,
              c = lastTriangles[i+2] +1;
        faces.push(`f ${a}/${a} ${b}/${b} ${c}/${c}`);
      }
      const objContent = [
        `mtllib facemesh.mtl`,
        `o FaceMesh`,
        ...verts,
        ...uvs,
        ...faces
      ].join('\n');
      const mtlContent = [
        `newmtl faceTex`,
        `Ka 1.000 1.000 1.000`,
        `Kd 1.000 1.000 1.000`,
        `map_Kd texture.png`
      ].join('\n');

      // Download helpers
      function download(blob, name) {
        const url = URL.createObjectURL(blob);
        const a   = document.createElement('a');
        a.href    = url;
        a.download= name;
        a.click();
        URL.revokeObjectURL(url);
      }

      download(texBlob,                    'texture.png');
      download(new Blob([mtlContent], {type:'text/plain'}), 'facemesh.mtl');
      download(new Blob([objContent], {type:'text/plain'}), 'facemesh.obj');
    });
  </script>
</body>
</html>
