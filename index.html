<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>FaceMesh + Camera Select + Textured OBJ Export</title>

  <!-- MediaPipe & utils -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <!-- Delaunator for triangulation -->
  <script src="https://cdn.jsdelivr.net/npm/delaunator@5.0.0/delaunator.min.js"></script>

  <style>
    /* General page styling */
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      background: linear-gradient(45deg, #6a11cb 0%, #2575fc 100%);
      overflow: hidden;
    }

    /* Container with glassmorphism */
    .container {
      position: relative;
      width: 80%;
      height: 80%;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
      padding: 20px;
      transition: transform 0.3s ease;
    }

    .container:hover {
      transform: scale(1.05);
    }

    /* Video & canvas */
    video, canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 16px;
      transition: opacity 0.5s ease;
    }

    /* Controls bar with hover effects */
    #controls {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 2;
      display: flex;
      gap: 12px;
      background: rgba(0, 0, 0, 0.6);
      padding: 12px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      opacity: 0.9;
      transition: opacity 0.3s ease;
    }

    #controls:hover {
      opacity: 1;
    }

    #controls select, #controls button {
      font-size: 16px;
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.3s ease, transform 0.3s ease;
    }

    #controls select {
      background: #333;
      color: #fff;
    }

    #controls button {
      background: #007BFF;
      color: white;
      font-weight: bold;
    }

    #controls button:hover {
      background: #0056b3;
      transform: translateY(-2px);
    }

    #controls select:focus, #controls button:focus {
      outline: none;
      box-shadow: 0 0 5px rgba(0, 123, 255, 0.8);
    }

    /* Buy Me a Coffee Button with smooth hover animation */
    #buyMeACoffeeBtn {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 20px;
      background-color: #ff813f;
      color: white;
      font-size: 18px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      border: none;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.3s ease;
    }

    #buyMeACoffeeBtn:hover {
      background-color: #e75a29;
      transform: scale(1.1);
    }

    #buyMeACoffeeBtn:focus {
      outline: none;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .container {
        width: 100%;
        height: 100%;
      }

      #controls {
        flex-direction: column;
        gap: 8px;
        top: 10px;
        left: 10px;
      }

      #controls select, #controls button {
        font-size: 14px;
        padding: 6px 12px;
      }

      #buyMeACoffeeBtn {
        bottom: 10px;
      }
    }

    /* Particle background effect */
    .particles {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
    }

    .particle {
      position: absolute;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.6);
      opacity: 0;
      animation: particle-animation 5s linear infinite;
    }

    @keyframes particle-animation {
      0% { transform: translate(0, 0); opacity: 1; }
      100% { transform: translate(200px, -300px); opacity: 0; }
    }

    /* Error message styling */
    #error-message {
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(255, 0, 0, 0.8);
      color: white;
      padding: 10px 20px;
      border-radius: 8px;
      display: none;
    }
  </style>
</head>
<body>

  <!-- Particle effect (background animation) -->
  <div class="particles"></div>

  <!-- Error message if webcam access fails -->
  <div id="error-message">Please allow access to your webcam to proceed.</div>

  <!-- Container with UI elements -->
  <div class="container">
    <!-- Controls: camera selector, start, toggle mesh, download -->
    <div id="controls">
      <select id="cameraSelect"></select>
      <button id="startCamBtn">Start Camera</button>
      <button id="toggleMeshBtn">Show Mesh</button>
      <button id="downloadBtn">Download OBJ+Texture</button>
    </div>

    <!-- Hidden video feed and overlay canvas -->
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>

    <!-- Buy Me a Coffee Button -->
    <button id="buyMeACoffeeBtn" onclick="window.open('https://buymeacoffee.com/soroushzenw', '_blank')">
      Support Me on BuyMeACoffee
    </button>
  </div>

  <script>
    // ---- 1) POLYFILL getUserMedia + enumerateDevices ----
    (function() {
      if (!navigator.mediaDevices) {
        navigator.mediaDevices = {};
      }
      if (!navigator.mediaDevices.getUserMedia) {
        const legacy = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
        if (legacy) {
          navigator.mediaDevices.getUserMedia = constraints =>
            new Promise((resolve, reject) =>
              legacy.call(navigator, resolve, reject, constraints)
            );
        } else {
          navigator.mediaDevices.getUserMedia = () =>
            Promise.reject(new Error('getUserMedia is not implemented'));
        }
      }
      if (!navigator.mediaDevices.enumerateDevices) {
        navigator.mediaDevices.enumerateDevices = () => {
          console.warn('enumerateDevices() not supported.');
          return Promise.resolve([]);
        };
      }
    })();

    // Warn if not secure context
    if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
      console.warn('⚠️ getUserMedia will only work on HTTPS (or http://localhost).');
    }

    // ---- DOM refs & state ----
    const videoEl      = document.getElementById('video');
    const canvasEl     = document.getElementById('overlay');
    const ctx          = canvasEl.getContext('2d');
    const selectCam    = document.getElementById('cameraSelect');
    const startCamBtn  = document.getElementById('startCamBtn');
    const toggleMeshBtn= document.getElementById('toggleMeshBtn');
    const downloadBtn  = document.getElementById('downloadBtn');
    const errorMessage = document.getElementById('error-message');

    let stream        = null;
    let stopLoop      = false;
    let showMesh      = false;
    let lastLM        = null;
    let lastTriangles = null;

    // ---- Particle effect ----
    function createParticle() {
      const p = document.createElement('div');
      p.classList.add('particle');
      const size = Math.random() * 5 + 2;
      p.style.width = `${size}px`;
      p.style.height = `${size}px`;
      p.style.left = Math.random() * 100 + '%';
      p.style.animationDuration = `${Math.random() * 3 + 2}s`;
      document.querySelector('.particles').appendChild(p);
      setTimeout(() => p.remove(), parseFloat(p.style.animationDuration) * 1000);
    }
    setInterval(createParticle, 100);

    // ---- MediaPipe FaceMesh init ----
    const faceMesh = new FaceMesh({
      locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`
    });
    faceMesh.setOptions({
      maxNumFaces: 1,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });
    faceMesh.onResults(onResults);

    // ---- List cameras safely ----
    async function listCameras() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const cams = devices.filter(d => d.kind === 'videoinput');
        selectCam.innerHTML = cams.map((cam,i) =>
          `<option value="${cam.deviceId}">${cam.label||'Camera '+(i+1)}</option>`
        ).join('');
      } catch (err) {
        console.warn('Could not list cameras:', err);
        selectCam.innerHTML = `<option value="">Default camera</option>`;
      }
    }
    listCameras();

    // ---- Start camera & feed FaceMesh ----
    startCamBtn.addEventListener('click', async () => {
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stopLoop = true;
      }
      const deviceId = selectCam.value || undefined;
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            deviceId: deviceId ? { exact: deviceId } : undefined,
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }
        });
        videoEl.srcObject = stream;
        await videoEl.play();
        errorMessage.style.display = 'none';

        stopLoop = false;
        (async function frameLoop() {
          await faceMesh.send({ image: videoEl });
          if (!stopLoop) requestAnimationFrame(frameLoop);
        })();
      } catch (error) {
        console.error('Camera access error:', error);
        errorMessage.style.display = 'block';
      }
    });

    // ---- Draw & triangulate on each FaceMesh result ----
    function onResults(results) {
      lastLM = results.multiFaceLandmarks?.[0] || null;
      canvasEl.width  = videoEl.videoWidth;
      canvasEl.height = videoEl.videoHeight;

      ctx.save();
      ctx.clearRect(0,0,canvasEl.width,canvasEl.height);
      ctx.drawImage(results.image, 0,0, canvasEl.width,canvasEl.height);

      if (lastLM) {
        const pts = lastLM.map(lm => [ lm.x * canvasEl.width, lm.y * canvasEl.height ]);
        lastTriangles = Delaunator.from(pts).triangles;

        if (showMesh) {
          ctx.fillStyle = 'rgba(0,255,0,0.3)';
          for (let i=0; i<lastTriangles.length; i+=3) {
            const [a,b,c] = [lastTriangles[i], lastTriangles[i+1], lastTriangles[i+2]];
            ctx.beginPath();
            ctx.moveTo(...pts[a]);
            ctx.lineTo(...pts[b]);
            ctx.lineTo(...pts[c]);
            ctx.closePath();
            ctx.fill();
          }
        }

        ctx.fillStyle = 'lime';
        for (const lm of lastLM) {
          const x = lm.x * canvasEl.width, y = lm.y * canvasEl.height;
          ctx.beginPath();
          ctx.arc(x, y, 2, 0, 2*Math.PI);
          ctx.fill();
        }
      }
      ctx.restore();
    }

    // ---- Toggle mesh visibility ----
    toggleMeshBtn.addEventListener('click', () => {
      showMesh = !showMesh;
      toggleMeshBtn.textContent = showMesh ? 'Hide Mesh' : 'Show Mesh';
    });

    // ---- Download OBJ + MTL + texture ----
    downloadBtn.addEventListener('click', async () => {
      if (!lastLM || !lastTriangles) {
        return alert('No face mesh detected yet!');
      }
      const texCanvas = document.createElement('canvas');
      texCanvas.width  = videoEl.videoWidth;
      texCanvas.height = videoEl.videoHeight;
      const texCtx = texCanvas.getContext('2d');
      texCtx.drawImage(videoEl, 0,0, texCanvas.width,texCanvas.height);
      const texBlob = await new Promise(res => texCanvas.toBlob(res,'image/png'));

      const verts = lastLM.map(lm =>
        `v ${lm.x.toFixed(6)} ${lm.y.toFixed(6)} ${lm.z.toFixed(6)}`
      );
      const uvs = lastLM.map(lm =>
        `vt ${lm.x.toFixed(6)} ${(1-lm.y).toFixed(6)}`
      );
      const faces = [];
      for (let i=0; i<lastTriangles.length; i+=3) {
        const a = lastTriangles[i]+1,
              b = lastTriangles[i+1]+1,
              c = lastTriangles[i+2]+1;
        faces.push(`f ${a}/${a} ${b}/${b} ${c}/${c}`);
      }

      const objContent = [
        `mtllib facemesh.mtl`,
        `o FaceMesh`,
        ...verts,
        ...uvs,
        ...faces
      ].join('\n');
      const mtlContent = [
        `newmtl faceTex`,
        `Ka 1.000 1.000 1.000`,
        `Kd 1.000 1.000 1.000`,
        `map_Kd texture.png`
      ].join('\n');

      const download = (blob, name) => {
        const url = URL.createObjectURL(blob);
        const a   = document.createElement('a');
        a.href    = url;
        a.download= name;
        a.click();
        URL.revokeObjectURL(url);
      };

      download(texBlob,                    'texture.png');
      download(new Blob([mtlContent], {type:'text/plain'}), 'facemesh.mtl');
      download(new Blob([objContent], {type:'text/plain'}), 'facemesh.obj');
    });
  </script>
</body>
</html>
